// To compile and upload...
// USB:        nbc -d -S=usb nxt.nxc
// Bluetooth:  nbc -d -S=BTH:M1 nxt.nxc

#include "lib.nxc"

const byte INBOX  = 1;
const byte OUTBOX = 2;

const byte MOTOR_PHI = OUT_A;
const byte MOTOR_TH  = OUT_B;

const char MOTOR_PHI_POLARITY = -1;
const char MOTOR_TH_POLARITY  = 1;
const char MOTOR_PHI_PWR = 100;
const char MOTOR_TH_PWR  = 100;
// const char MOTOR_PWR_PER_RADIAN = 100;
const float GRAVITY_FACTOR = 5.0;

const float CAMERA_PHI = PI / 6;
const float XY_SCALE = CAMERA_PHI / 2;

// Globals
Angle2 curr_pos;
int pwr_phi = 0;
int pwr_th  = 0;
long encoder_home_phi = 0;
long encoder_home_th  = 0;

// TODO Needed for accurate setpoint prediction using encoder data!
const float MOTOR_PHI_GEAR_RATIO = 1;
const float MOTOR_TH_GEAR_RATIO  = 1;

// Convert input motor coordinates to position
Angle2 coords_to_pos(Vector2 coords) {
	// TODO Should maybe update setpoint or something...?
	// TODO quaternions, rotations, projective geometry?
	Angle2 pos;
	pos.phi = -XY_SCALE * coords.x / sin(curr_pos.th);
	pos.th  = -XY_SCALE * coords.y;
	return pos;
}

// Drive to absolute position in terms of (phi, th)
void drive_to_pos(Angle2 pos) {
	// TODO use absolute position rather than relative degrees
	// TODO predict point location in time t using velocity
	// TODO PID
	// TODO smarter pathing
	// TODO resistance/drag modelling

	int pwr_gravity = GRAVITY_FACTOR * Sin(curr_pos.th);

	pwr_phi = pos.phi * MOTOR_PHI_PWR;
	pwr_th  = pos.th  * MOTOR_TH_PWR  + pwr_gravity;

	pwr_phi = CONSTRAIN(pwr_phi, -50, 50);
	pwr_th  = CONSTRAIN(pwr_th,  -30, 30);

	OnFwd(MOTOR_PHI, MOTOR_PHI_POLARITY * pwr_phi);
	OnFwd(MOTOR_TH,  MOTOR_TH_POLARITY  * pwr_th);
}

void refresh_curr_pos() {
	long encoder_phi = MotorRotationCount(MOTOR_PHI);
	long encoder_th  = MotorRotationCount(MOTOR_TH);

	curr_pos.phi = MOTOR_PHI_POLARITY * MOTOR_PHI_GEAR_RATIO * (encoder_phi - encoder_home_phi);
	curr_pos.th  = MOTOR_TH_POLARITY  * MOTOR_TH_GEAR_RATIO  * (encoder_th  - encoder_home_th);
}

void set_home() {
	encoder_home_phi = MotorRotationCount(MOTOR_PHI);
	encoder_home_th  = MotorRotationCount(MOTOR_TH);
}

// Parses msg of format "(x,y)"
Vector2 parse_msg(string msg) {
	int idx = Pos(",", msg);
	Vector2 coords;
	coords.x = 0.001 * StrToNum(SubStr(msg, 1, idx - 1));
	coords.y = 0.001 * StrToNum(SubStr(msg, idx + 1, StrLen(msg) - idx - 2));
	return coords;
}

task main() {
	ClearScreen();
	TextOut(0, LCD_LINE1, "EagleEyeTracker");
	TextOut(0, LCD_LINE2, "Please home");

	set_home();

	Angle2 pos;
	Vector2 coords;
	unsigned long refresh_display_tick = CurrentTick();

	while (true) {
		string msg = "";
		char status = ReceiveRemoteString(INBOX, true, msg);

		if (status != STAT_MSG_EMPTY_MAILBOX) {
			coords = parse_msg(msg);
			pos = coords_to_pos(coords);
		}

		refresh_curr_pos();

		if (refresh_display_tick + 100 <= CurrentTick()) {
			refresh_display_tick = CurrentTick();

			string status_str = "";
			if (status == STAT_MSG_EMPTY_MAILBOX)
				status_str = "Waiting for msg";

			ClearScreen();
			TextOut(0,   LCD_LINE1, "EagleEyeTracker");
			TextOut(0,   LCD_LINE2, status_str);
			NumOut( 0,   LCD_LINE5, pwr_phi);
			NumOut( 6*4, LCD_LINE5, pwr_th);
			TextOut(0,   LCD_LINE6, Angle2_str(pos));
			TextOut(0,   LCD_LINE7, Vector2_str(coords));
			TextOut(0,   LCD_LINE8, msg);
		}

		// TODO use controller to home/pause driving/etc
		if (ButtonPressed(BTNCENTER)) {
			Coast(OUT_ABC);
			continue;
		}

		drive_to_pos(pos);
	}
}

