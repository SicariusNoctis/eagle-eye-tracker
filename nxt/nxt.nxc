// To compile and upload...
// USB:        nbc -d -S=usb nxt.nxc
// Bluetooth:  nbc -d -S=BTH:M1 nxt.nxc

const byte BT_CONN_MASTER = 0;
const byte BT_CONN_SLAVE = 1;
const byte INBOX = 1;
const byte OUTBOX = 2;

const byte MOTOR_PHI = OUT_A;
const byte MOTOR_TH = OUT_B;

const char MOTOR_PHI_PWR = 40;
const char MOTOR_TH_PWR = 100;
const float XY_SCALE = 1000.0;

struct Angle2 {
	float phi;
	float th;
};

struct Vector2 {
	float x;
	float y;
};

// Drive to absolute position in terms of (phi, th)
void drive_to_pos(Angle2 pos) {
	// TODO use absolute position rather than relative degrees
	// TODO predict point location in time t using velocity
	// TODO RotateMotorPID
	// TODO Use non-blocking API
	// RotateMotor(MOTOR_PHI, MOTOR_PHI_PWR, pos.phi);
	// RotateMotor(MOTOR_TH, MOTOR_TH_PWR, pos.th);

	// RotateMotor();
}

Angle2 coords_to_pos(Vector2 coords) {
	// TODO quaternions, rotations, projective geometry
	Angle2 pos;
	// pos.phi = coords.x;
	// pos.th  = coords.y;
	pos.phi = -XY_SCALE * coords.x; // TODO / sin(curr.th);
	pos.th  = -XY_SCALE * coords.y;
	return pos;
}

// Parses msg of the format (x,y)
Vector2 parse_msg(string msg) {
	int idx = Pos(",", msg);

	Vector2 coords;
	coords.x = StrToNum(SubStr(msg, 1, idx - 1));
	coords.y = StrToNum(SubStr(msg, idx + 1, StrLen(msg) - idx - 2));

	return coords;
}

task main() {
	ClearScreen();
	TextOut(0, LCD_LINE1, "EagleEyeTracker");
	TextOut(0, LCD_LINE3, "Please home");

	// TODO keep track of current pos
	// Angle2 curr_pos = Angle2(0., 0.);

	while (true) {
		// TODO what is msg size limit?
		string msg = "";
		char status = ReceiveRemoteString(INBOX, true, msg);

		if (status == STAT_MSG_EMPTY_MAILBOX) {
			TextOut(0, LCD_LINE7, "Waiting for msg");
			continue;
		}

		Vector2 coords = parse_msg(msg);
		Angle2 pos = coords_to_pos(coords);
		drive_to_pos(pos);

		ClearScreen();
		TextOut(0, LCD_LINE1, "EagleEyeTracker");
		TextOut(0, LCD_LINE8, msg);
	}
}
